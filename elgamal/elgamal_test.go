package elgamal

import (
	"crypto/rand"
	"testing"

	. "gopkg.in/check.v1"

	"github.com/twtiger/crypto/curve"
	"github.com/twtiger/crypto/utils"
)

func Test(t *testing.T) { TestingT(t) }

type EGSuite struct{}

var _ = Suite(&EGSuite{})

var (
	egRandData = []byte{
		// x1
		0x40, 0x80, 0x66, 0x2d, 0xd8, 0xe7, 0xf0, 0x9c,
		0xdf, 0xb0, 0x4e, 0x1c, 0x6e, 0x12, 0x62, 0xa3,
		0x7c, 0x31, 0x9a, 0xe1, 0xe7, 0x86, 0x87, 0xcc,
		0x82, 0x05, 0x78, 0xe6, 0x44, 0x2f, 0x4f, 0x77,
		0x0e, 0xd1, 0xb4, 0x48, 0xa6, 0x05, 0x90, 0x5e,
		0xe7, 0xba, 0xfc, 0x25, 0x99, 0x99, 0xb8, 0xc3,
		0x90, 0x3e, 0xf4, 0xa3, 0x75, 0xee, 0x85, 0x32,
	}

	testPriv = &PrivateKey{
		// X
		curve.Ed448GoldScalar([]byte{
			0xc6, 0xd0, 0x98, 0x2e, 0xe4, 0xe5, 0x81, 0xe4,
			0x61, 0x3c, 0x46, 0x99, 0x0a, 0x37, 0x79, 0xc3,
			0xfa, 0xe5, 0xd5, 0x29, 0x27, 0x31, 0xa3, 0x55,
			0x9f, 0x34, 0x91, 0xd1, 0x0c, 0x7f, 0x88, 0x56,
			0x8c, 0x62, 0xe1, 0x86, 0xb7, 0xef, 0xd6, 0xcb,
			0x1b, 0x14, 0x88, 0x3b, 0xc0, 0xfb, 0xac, 0x46,
			0x0c, 0xc7, 0x20, 0x82, 0x3e, 0xd0, 0xdc, 0x2c,
		},
		),
	}

	testPub = &PublicKey{
		// Y
		curve.Ed448GoldPoint(
			[16]uint32{
				0x0ccd1054, 0x0dd85c70, 0x095dc098, 0x005fdf78,
				0x0f6d2050, 0x064a76af, 0x08363bce, 0x014325f1,
				0x0574263a, 0x04c5b6be, 0x01774dc9, 0x0d2102d1,
				0x031d3ab4, 0x0f255544, 0x0eec4139, 0x01a69a40,
			},
			[16]uint32{
				0x08c35ab3, 0x02edc945, 0x0d60b971, 0x0ccb4b14,
				0x08a6c14d, 0x0f4dcafc, 0x07bf5b20, 0x0fcacf39,
				0x0b8bd792, 0x0f092fae, 0x05b99a1a, 0x0163bd6e,
				0x0275ef84, 0x0b2099af, 0x01c21cf4, 0x0e899e8f,
			},
			[16]uint32{
				0x01e21a42, 0x0e282ee6, 0x01461de1, 0x09e55da9,
				0x0ad9b37b, 0x0e196475, 0x0f5107e1, 0x05e71693,
				0x0abf627f, 0x07726e64, 0x07b2e3b6, 0x0831b5f0,
				0x09af28b3, 0x0b30120d, 0x05c4cc70, 0x0bce3ad4,
			},
			[16]uint32{
				0x07da6911, 0x0260b301, 0x09b58d5f, 0x05891723,
				0x06d85cdd, 0x0ca5e904, 0x0d39cf35, 0x0b81a57b,
				0x0d1f56d4, 0x09b4efc3, 0x0ad08b05, 0x0edb9f3d,
				0x0b4107cd, 0x081b9d45, 0x030b4941, 0x0bdd68bc,
			},
		),
	}
)

func (s *EGSuite) Test_DerivePrivateKey(c *C) {
	eg := &ElGamal{&curve.Ed448Gold{}}
	priv, err := eg.derivePrivKey(utils.FixedRand(egRandData))

	c.Assert(priv, DeepEquals, testPriv)
	c.Assert(err, IsNil)

	r := make([]byte, 55)
	_, err = eg.derivePrivKey(utils.FixedRand(r))

	c.Assert(err, ErrorMatches, "cannot source enough entropy")
}

func (s *EGSuite) Test_GenerateKeys(c *C) {
	eg := &ElGamal{&curve.Ed448Gold{}}
	pair, err := eg.GenerateKeys(utils.FixedRand(egRandData))
	c.Assert(pair.Pub.Y, DeepEquals, testPub.Y)
	c.Assert(pair.Priv, DeepEquals, testPriv)
	c.Assert(err, IsNil)

	r := make([]byte, 55)
	_, err = eg.GenerateKeys(utils.FixedRand(r))

	c.Assert(err, ErrorMatches, "cannot source enough entropy")
}

func (s *EGSuite) Test_EncryptionAndDecryption(c *C) {
	eg := &ElGamal{&curve.Ed448Gold{}}
	message := []byte{
		0xfd, 0xf1, 0x18, 0xbf, 0x8e, 0xc9, 0x64, 0xc7,
		0x94, 0x46, 0x49, 0xda, 0xcd, 0xac, 0x2c, 0xff,
		0x72, 0x5e, 0xb7, 0x61, 0x46, 0xf1, 0x93, 0xa6,
		0x70, 0x81, 0x64, 0x37, 0x7c, 0xec, 0x6c, 0xe5,
		0xc6, 0x8d, 0x8f, 0xa0, 0x43, 0x23, 0x45, 0x33,
		0x73, 0x79, 0xa6, 0x48, 0x57, 0xbb, 0x0f, 0x70,
		0x63, 0x8c, 0x62, 0x26, 0x9e, 0x17, 0x5d, 0x22,
	}

	keyPair, err := eg.GenerateKeys(rand.Reader)
	c1, c2, err := eg.Encrypt(rand.Reader, keyPair.Pub, message)
	expMessage := eg.Decrypt(keyPair.Priv, c1, c2)

	c.Assert(expMessage, DeepEquals, message)
	c.Assert(err, IsNil)

	keyPair, err = eg.GenerateKeys(rand.Reader)
	c1, c2, err = eg.Encrypt(utils.FixedRand([]byte{0x00}), keyPair.Pub, message)

	c.Assert(expMessage, DeepEquals, message)
	c.Assert(err, ErrorMatches, "cannot source enough entropy")
}
